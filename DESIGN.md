## 데이터 분석

- 전체적으로는 건축, 구조 등의 공종 목록과, 도면 객체과 키-값 객체로 들어있는 구조로 해석했고, drawing 안에는 계층 구조/위치 정보/공종별 데이터와 transform에는 이미지 배치를 위한 좌표 변환 / 폴리곤 영역의 좌표 변환 / 상대 좌표 기준 이미지, regions에는 A,B,C 등의 분할 영역이 존재해 각 리비전 별로 다른 도면을 보여주는 구조로 해석했습니다.
- 처음에는 json 데이터를 일일이 파고들어서 접근했으나 모든 구조 패턴이 동일하지 않기 때문에 옵셔널 체이닝 기법을 사용해야 했습니다. 그러나 이러한 방법은 가독성 면이나 데이터 안정성에서 좋지 않다는 것을 알고 **정규화 작업**을 통해 개선했습니다.

## 접근 방식

-   1. 사용자의 시나리오를 읽고 난 후 파악했던 핵심은 **어떤 리비전이 최신 버전**인지, **어떤 공종끼리 겹쳐봐야** 하는 것이었습니다.
-   2. 우선 metadata.json의 구조가 중첩이 여러 번 되어있는 구조로 파악했습니다.

위와 같은 형태로 체이닝을 하게 되면 코드 가독성이 좋지 않을 것이라고 판단해서 데이터 정규화 작업이 필요할 것으로 판단했습니다.

- 부모, 자식 간의 관계를 표현하기 위해 정규화를 진행하여 트리 구조로 보여주었습니다.

1. 사용자의 시나리오 및 요구사항 파악
2. 데이터 정규화

- metadata.json의 복잡한 트리구조를 명확히 하기 위해 정규화 로직을 작성

3. 도면 탐색 -> 도면 표시 -> 컨텍스트 인식 순으로 UI 구현
4. 현재 리비전과 이전 리비전을 오버레이 겹침을 통한 비교
5. 공종 간의 오버레이 겹침을 통한 비교

## UI 설계 결정

### 도면 탐색 및 표시

- 처음에는 탭 UI 구조를 생각했었으나, 체 배치도(부모) > 주차장 / 101동 / 주민공동시설(자식) 에 대한 관계를 보여주기 위해서는 트리 구조로 보여주는 게 적절하다고 판단했고 이를 나타내기 위해 **사이드바 형태의 UI**를 채택했습니다.
- 도면 탐색을 단순히 도면을 '탐색'하는 것으로 생각했지만 시설별 / 공종별 / 리비전 별로 보여주는 도면이 모두 다르기 때문에 가장 먼저 드롭다운으로 필터링 해주는 게 적절하다고 판단했습니다.
- 처음에는 도면의 각 리비전별로 이름만 나타냈지만, `metadata.json` 내 `date`를 확인했고 최신 리비전이 무엇인지를 나타내기 위해 date를 비교하는 로직을 작성해서 나타냈습니다.
- 또한 `metadata.json` 내 `changes`를 이용해서 현재 리비전과 다른 리비전을 비교해서 어떤 부분이 변경됐는지(ex. "헬스장 확장", "로비 공간 조정") 패널 형태로 보여주도록 했습니다.
- 원본 도면 이미지는 너무 작아서 제대로 보이지 않기 때문에 `줌인/줌아웃` 기능을 사용하여 확대 및 축소가 가능하도록 했고, 팬 기능을 추가하여 드래그를 통해 볼 수 있도록 했습니다.
- 요구사항에는 크게 `도면 탐색`, `도면 표시`, `컨텍스트 인식`으로 나와있었지만 시나리오 상으로 어떤 공종끼리 겹쳐봐야 하는지 파악할 수 있도록 하기 위해 오버레이 겹침 기법을 사용했습니다.
- 오버레이 겹침 기능을 구현할 때, 원본 이미지를 그대로 사용하는 방법을 적용했었으나, 사용자가 보기에 헷갈릴수도 있다는 점을 감안하여 **투명도를 조절**하는 기법을 추가했습니다.

### 컨텍스트 인식

- 처음에는 **브레드크럼**을 생각했으나, 도면 목록의 이름이 길어질 경우 말줄임 형태로 생략해야 하거나 줄바꿈이 될 우려가 있기 때문에, 헤더 내 텍스트 형태로 보여주도록 선택했습니다.

## 기술 선택

### Context API

- 현재 프로젝트 요구사항에 따르면, 선택된 공종, 리비전 등의 상태를 알아야 하고 사이드바 토글 상태, 비교 모드, 다중 오버레이 상태를 모두 useState로 관리하게 되면 이에 따른 props drilling이 심해질 것 같아 추후에 기능이 추가될 때 유지보수가 힘들어 질것이라 판단했습니다. 또한 zustand 같은 라이브러리를 쓰기에는 현재 프로젝트 규모에는 오버 엔지니어링에 해당한다고 생각했습니다. 지금은 React의 내장 기능인 Context API를 사용했지만 기능이 복잡해질 경우 zustand 같은 라이브러리도 도입해 볼 것 같습니다.

### Tailwind CSS

- styled-components나 .css 파일을 통해 작업하면서 컴포넌트 네이밍이나 css 클래스 네임을 짓는 부분에 대해 번거로웠던 경험이 있었습니다. 빠른 레이아웃을 만들어 내기 위해 Tailwind CSS를 선택했습니다.

## 어려웠던 점 및 개선 방안

### 어려웠던 점

### 줌인/줌아웃

- 줌인/줌아웃을 구현하면서 어려웠던 점은 마우스 휠을 통해 확대 및 축소를 할 때 단순히 배율만 변경했으나 x,y 좌표 변경으로 인해 원하는 지점의 도면 이미지를 제대로 보기 어려웠고, 좌표 계산 개선을 통해 현재 포인터의 좌표에서 확대되도록 했습니다.
- 과도하게 확대하게 되면 픽셀이 깨지는 경우가 있는데, 이 기준에 대해 명확히 하는게 어려웠습니다.

### 반응형

- 건설 현장에서는 PC 화면을 보기가 사실상 불가능하기 때문에 모바일이나 태블릿을 사용할 것입니다. 이 경우에는 모바일 및 태블릿 화면에서 레이아웃을 달리해야 하는데, 브레이크 포인트를 어떻게 지정해야 할 지 기준을 잡기 어려웠습니다.
- 또한 모바일 화면에서는 줌인/줌아웃 기능이 필요할 것으로 보이는데, 이 경우에는 핀치 줌과 같은 제스처를 구현해야 하는데, PC 화면에서와 달리 기준을 잡기가 어려웠습니다.

### 개선 방안

- 시간이 좀 더 주어진다면 여러 기기에서의 레이아웃을 어떻게 설계할지 고민해보고 반응형을 적용할 것입니다.
- PC 환경에서 마우스 휠을 통한 줌인/줌아웃과 모바일 환경에서 핀치 투 줌을 통한 줌인/줌아웃의 차이점을 고려해서 확대/축소 로직을 개선하고 싶습니다.
- Tailwind CSS 사용 시 클래스네임이 길어짐으로 인해 가독성이 떨어질 우려가 있는데, tailwind-merge 등의 라이브러리를 이용해서 코드 가독성을 향상시킬 것입니다.
